# Описание деталей имплементации

## Задачи

* клиент может поддерживать HTTP-запросы/ответы со сжатием данных;
* Каждый логин должен быть уникальным.

## Вопросы (ответы)

1. WithdrawPoints сейчас работает не атомарно.

## Сервисы

* auth
* api (router)
* orders
* сервис взаимодействия с accrual

### Auth

Реализовать JWT
Реализовать проверку, что пользователь является владельцем заказа.

Задачи:

* регистрация
* аутентификация
* авторизация (проверка соответствеия userid в заказе?)

Хендлеры:

* `POST /api/user/register` — регистрация пользователя;
* `POST /api/user/login` — аутентификация пользователя;

### Orders

Задачи:

* приём номеров заказов от зарегистрированных пользователей (?что такое прием номеров, для чего?)
* учёт и ведение списка переданных номеров заказов зарегистрированного пользователя;
* учёт и ведение накопительного счёта зарегистрированного пользователя;
* проверка принятых номеров заказов через систему расчёта баллов лояльности;
* начисление за каждый подходящий номер заказа положенного вознаграждения на счёт лояльности пользователя.

Хендлеры:

* `POST /api/user/orders` — загрузка пользователем номера заказа для расчёта;
* `GET /api/user/orders` — получение списка загруженных пользователем номеров заказов, статусов их обработки и информации о начислениях;
* `GET /api/user/balance` — получение текущего баланса счёта баллов лояльности пользователя;
* `POST /api/user/balance/withdraw` — запрос на списание баллов с накопительного счёта в счёт оплаты нового заказа;
* `GET /api/user/withdrawals` — получение информации о выводе средств с накопительного счёта пользователем.

! списания должны быть атомарными, баланс не отрицательный

### Сервис взаимодействия с accrual

Асинхронный сервис. Запускается в фоне с заданной периодичностью.

* обращается к accrual `GET /api/orders/{number}`
* при получении статуса `INVALID` маркирует заказ как обработанный, баллы не начисляет
* при получении статуса `PROCESSED` маркирует заказ как обработанный и добавляет владельцу этих заказов баллы на счёт
* при получении статуса `204` - заказ не зарегистрирован в системе расчета переносит проверку на следующую итерацию (либо изначально не проверяет заказы не промаркированные как зарегистрированные)
* при получении статуса `500` делает N повторений после чего переносит проверку на следующую итерацию
* при получении статуса `429` — превышено количество запросов !Retry-After: 60 нужно обработать

Алгоритм работы сервиса:

Константы:
pollInterval - 10s
maxRetries - 3
availabilityMarker - time

* Запускаемся раз в 10 сек.
* Получаем заказы со статусом NEW
* Получаем заказы со статусом PROCESSING

* каждые pollInterval запускаемся
  * Для заказов со статусом NEW, PROCESSING
    * Проверяем маркер доступности
      * выходим из цикла
    * Отправляем в accrual `GET /api/orders/{number}`
      * Повторяем N раз (backoff) в случае 500
        * Меняем маркер доступности в случае 429
          * выходим из цикла
      * Меняем маркер доступности в случае 429
        * выходим из цикла
    * если статус в accrual REGISTERED|PROCESSING
      * переводим в PROCESSING
    * если статус в accrual PROCESSED
      * переводим в PROCESSING
      * обновляем поле accrual в таблице orders для заказа
    * если статус в accrual INVALID
      * переводим в INVALID

Вне спецификации:
<!-- игнорируем, но т.к. всё равно скажут: ты не реализовал, а должен был сходить и отреверсить бинарь accrual или посмотреть в какое-то ещё левое ТЗ, то лучше учитывать при планировании -->
* Для заказов со статусом NEW (по инфре всё тоже, что и в предыдущем)
  * Отправляем в accrual `POST /api/orders`
  * если 202
    * переводим в статус PROCESSING (это нигде не декларируется, что 202 == "PROCESSING", поэтому будем и для NEW проверять изменение статуса)


## База данных

!подумать над добавлением таблицы balance

Таблицы:

* users
* orders
* withdrawals

Таблица users:

* id
* login
* password_hash

Таблица orders:

* id
* user_id
* number
* status

Таблица withdrawals:

* id
* user_id
* order_number
* sum

## Требования из вебинара

* [ ] WithdrawPoints должен быть атомарный
* [x] 429 от accrual должен блокировать весь worker pool на указанное время, а не только одну горутину. (удобнее делать через "разделяемую память", мьютексы, атомики и тп, чем через фан аут в каналах)
* [x] флаги должны быть более приоритетными, чем переменные окружения
* [x] добавить линтер и actions
* [x] graceful shutdown
* [ ] сжатие делать только когда возвращается список
* [x] README.md должен содержать информацию по запуску сервиса
* [ ] рестарт сервиса не должен приводить к потере заказа принятого в обработку

Опциональные:

* [ ] перейти на viper/pflags
* [ ] добавить генерацию openapi
* [ ] добавить бейдж с coverage на github
* [ ] добавить пейджирование в /api/user/withdrawals но отдельным эндпоинтом, т.к. автотесты не поддерживают.

> можете не делать алгоритм Луна.

не можете т.к. вы всё равно будете вынуждены работать с accrual, а он валидирует номера по Луну, т.е. лучше разобраться.
